
fs = require 'fs'
path = require 'path'
child_process = require 'child_process'
events = require('events')

re_trailing_path = /\/?$/


mkdirp = (dir, cb) ->
  child_process.exec "mkdir -p #{JSON.stringify dir}", cb


group_cb = null
do ->
  ee = new events.EventEmitter()
  groups = {}

  event_cb = (event_name) ->
    group = groups[event_name] ?= {data: [], length: 0, updated: 0}
    idx = group.length
    group.length += 1
    ->
      group.data[idx] = arguments
      group.updated += 1
      #console.log group
      if group.updated is group.length
        group[event_name] = null
        ee.emit event_name, group.data...

  group_cb = (cb) ->
    event_name = '' + Math.random()
    if cb
      ee.on(event_name, cb)
    ret = ->
      ret.count += 1
      event_cb(event_name)
    ret.count = 0
    ret



notDirError = (path) ->
  err = new Error("Not a directory: #{JSON.stringify path}")
  err.path = path
  err.code = 'ENOTDIR'


re_to_capital_case = /(^|[\-_\s])([a-z])/g
to_capital_case = (name) ->
  result = name.replace re_to_capital_case, (a, b, match) -> match.toUpperCase()
  result.replace re_trailing_path, ''


get_object_path = (namespace, basename) ->
  "#{namespace}.#{to_capital_case basename}"


default_object_paths = (object_paths...) ->
  defaults = []
  for object_path in object_paths
    parts = object_path.split '.'
    _parts = [parts[0]]
    parts = parts.slice 1

    for part in parts
      _parts.push part
      part = _parts.join '.'
      _default = "#{part} || (#{part} = {});"
      if _default not in defaults
        defaults.push _default

  defaults.join '\n'


@compile = ({source_dir, out_dir, file_level, extension, namespace}) ->
  stats_cb = group_cb ([err1], [err2]) ->
    throw err if (err = err1 or err2)
    _compile source_dir, out_dir, file_level, new RegExp("\\.#{extension}$", 'i'), namespace

  cb1 = stats_cb()
  cb2 = stats_cb()
  srcstat = fs.stat source_dir, (err, stat) ->
    throw err if err
    if not stat.isDirectory()
      cb1(notDirError source_dir)
    else
      cb1()

  out_dirstat = fs.stat out_dir, (err, stat) ->
    if err and err.code isnt 'ENOENT'
      throw err
    else if !stat || stat.isDirectory()
      cb2()
    else
      cb2(notDirError out_dir)


_compile = (source_dir, out_dir, file_level, re_extension, namespace, cb) ->
  results =
    items: []
    out_dir: out_dir
    source_dir: source_dir

  basename = (path.basename source_dir).replace re_trailing_path, ''
  object_path = get_object_path namespace, basename

  item_cb = group_cb ->
    for info in arguments
      [err, branch_info] = info or []
      throw err if err
      if branch_info
        [dir, branch] = branch_info
        results.items.push
          type: 'directory'
          data: branch
          name: dir

    if file_level >= 0
      _compile_with_branches results, object_path, cb
    else if cb?
      cb null, [basename, results]

  stat_cb = group_cb ->
    if not item_cb.count
      item_cb() null

  fs.readdir source_dir, (err, contents) ->
    throw err if err
    for item in contents then do (item) ->
      scb = stat_cb()
      itempath = path.join source_dir, item
      fs.stat itempath, (err, stat) ->
        throw err if err
        if stat.isDirectory()
          new_out_dir = path.join out_dir, item
          _compile itempath, new_out_dir, file_level - 1, re_extension, object_path, item_cb()
        else if re_extension.test item
          _cb = item_cb()
          entry = item.replace re_extension, ''
          fs.readFile itempath, 'utf8', (err, data) ->
            results.items.push
              type: 'file'
              data: data
              name: entry
            _cb err
        scb null


warning_message = """
/** WARNING: This file is automatically generated by plate.
*   Do not edit this file if you plan on using plate to continue to
*   generate template files. If you run plate on your templates again,
*   all changes to this file will be lost!
*/
"""
_compile_with_branches = (data, object_path, cb) ->
  # Get a copy of the callback that won't take any arguments
  cb = do (cb) ->
    -> cb and cb()

  #console.log data

  if not data.items.length
    cb()
  else
    _cb = group_cb cb
    object_paths = []
    js_head = """
    #{warning_message}

    """
    js_body = ""
    for name, info of data.items then do (name, info) ->
      if info.type is 'file'
        object_paths.push object_path
        js_body += """
        #{object_path}.#{info.name} = _.template(
          #{JSON.stringify info.data}
        );

        """

      else if info.type is 'directory'
        _compile_with_branches info.data, get_object_path(object_path, info.name), _cb()

    mkdirp data.out_dir, (err) ->
      throw err if err
      out = path.join data.out_dir, "#{path.basename data.source_dir}.js"
      console.log "writing #{JSON.stringify out} to file..."
      js_head += default_object_paths object_paths...
      js = js_head + '\n' + js_body
      fs.writeFile out, js, 'utf8', _cb()

