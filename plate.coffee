
fs = require 'fs'
path = require 'path'
child_process = require 'child_process'
events = require 'events'
readline = require 'readline'
try
  _ = require 'underscore'

with_prompter = (fn) ->
  prompter = readline.createInterface
    input: process.stdin
    output: process.stdout
  fn prompter, ->
    prompter.close()

re_trailing_path = /\/?$/


mkdirp = (dir, cb) ->
  child_process.exec "mkdir -p #{JSON.stringify dir}", cb


rmdirr = (dir, force, cb) ->
  _dir = JSON.stringify dir
  _f = if force then 'f' else ''
  cmd = "if [ -d #{_dir} ]; then rm -r#{_f} #{_dir}; fi"
  child_process.exec cmd, cb

group_cb = null
do ->
  ee = new events.EventEmitter()
  groups = {}

  event_cb = (event_name) ->
    group = groups[event_name] ?= {data: [], length: 0, updated: 0}
    idx = group.length
    group.length += 1
    ->
      group.data[idx] = arguments
      group.updated += 1
      #console.log group
      if group.updated is group.length
        group[event_name] = null
        ee.emit event_name, group.data...

  group_cb = (cb) ->
    event_name = '' + Math.random()
    if cb
      ee.on(event_name, cb)
    ret = ->
      ret.count += 1
      event_cb(event_name)
    ret.count = 0
    ret



notDirError = (path) ->
  err = new Error("Not a directory: #{JSON.stringify path}")
  err.path = path
  err.code = 'ENOTDIR'


re_to_capital_case = /(^|[\-_\s])([a-z])/g
to_capital_case = (name) ->
  result = name.replace re_to_capital_case, (a, b, match) -> match.toUpperCase()
  result.replace re_trailing_path, ''


get_object_path = (namespace, basename) ->
  "#{namespace}.#{to_capital_case basename}"


default_object_paths = (object_paths...) ->
  defaults = []
  for object_path in object_paths
    parts = object_path.split '.'
    _parts = [parts[0]]
    parts = parts.slice 1

    for part in parts
      _parts.push part
      part = _parts.join '.'
      _default = "#{part} || (#{part} = {});"
      if _default not in defaults
        defaults.push _default

  defaults.join '\n'


clean_out_dir = (argv, cb) ->
  with_prompter (prompter, close) ->
    clean = (yn) ->
      close()
      if yn in [true, 'y', 'Y']
        console.log "Cleaning out previously compiled files, if any."
        rmdirr(argv.out_dir, false, cb)
    if argv.unsafe_clean
      clean true
    else
      prompter.question(
        "Really remove #{JSON.stringify argv.out_dir} and all its contents? (Y/n) ",
        clean
      )


@compile = (argv) ->
  {source_dir, out_dir, compile_style, extension, namespace} = argv
  stats_cb = group_cb ([err1], [err2]) ->
    throw err if (err = err1 or err2)
    argv.re_extension = new RegExp("\\.#{extension}$", 'i')
    _compile argv.source_dir, argv.out_dir, argv.namespace, argv

  cb1 = stats_cb()
  srcstat = fs.stat source_dir, (err, stat) ->
    throw err if err
    if not stat.isDirectory()
      cb1(notDirError source_dir)
    else
      cb1()

  out_cb = stats_cb()
  out_dirstat = fs.stat out_dir, (err, stat) ->
    if err and err.code isnt 'ENOENT'
      throw err
    else if !stat
      out_cb()
    else if stat.isDirectory()
      if argv.clean
        clean_out_dir argv, out_cb
      else
        out_cb()
    else
      out_cb(notDirError out_dir)


_compile = (source_dir, out_dir, namespace, argv, cb) ->
  results =
    items: []
    out_dir: out_dir
    source_dir: source_dir

  basename = (path.basename source_dir).replace re_trailing_path, ''
  object_path = get_object_path namespace, basename

  item_cb = group_cb ->
    for info in arguments
      [err, branch_info] = info or []
      throw err if err
      if branch_info
        [dir, branch] = branch_info
        results.items.push
          type: 'directory'
          data: branch
          name: dir

    _compile_with_branches results, object_path, argv, cb

  stat_cb = group_cb ->
    if not item_cb.count
      item_cb() null

  fs.readdir source_dir, (err, contents) ->
    throw err if err
    for item in contents then do (item) ->
      scb = stat_cb()
      itempath = path.join source_dir, item
      fs.stat itempath, (err, stat) ->
        throw err if err
        if stat.isDirectory()
          if argv.compile_style isnt 'combined'
            new_out_dir = path.join out_dir, item
          else
            new_out_dir = out_dir
          _compile itempath, new_out_dir, object_path, argv, item_cb()
        else if argv.re_extension.test item
          _cb = item_cb()
          entry = item.replace argv.re_extension, ''
          fs.readFile itempath, 'utf8', (err, data) ->
            results.items.push
              type: 'file'
              data: data
              name: entry
            _cb err
        scb null


warning_message = """
/** WARNING: This file is automatically generated by plate.
 *  Do not edit this file if you plan on using plate to continue to
 *  generate template files. If you run plate on your templates again,
 *  all changes to this file will be lost!
 */
"""
_compile_with_branches = (data, object_path, argv, cb) ->
  # Get a copy of the callback that won't take any arguments
  cb = do (cb) ->
    -> cb and cb()

  #console.log data

  if not data.items.length
    cb()
  else
    mkdirp data.out_dir, (err) ->
      throw err if err

      _cb = group_cb cb
      js_head = """
      #{warning_message}

      """

      js_body = null
      object_paths = null
      setup_defaults = ->
        js_body = ""
        object_paths = []
      setup_defaults()

      write = ->
        out = path.join data.out_dir, "#{path.basename data.source_dir}.js"
        console.log "writing #{JSON.stringify out} to file..."
        js_head += default_object_paths object_paths...
        js = js_head + '\n\n' + js_body
        fs.appendFile out, js, {encoding: 'utf8'}, _cb()
        setup_defaults()

      underscore_opts = {}
      if argv.underscore_variable
        underscore_opts.variable = argv.underscore_variable

      for name, info of data.items then do (name, info) ->
        if info.type is 'file'
          object_paths.push object_path

          template_fn = """
          _.template(
              #{JSON.stringify info.data},
              null, #{JSON.stringify underscore_opts})
          """
          if _ and not argv.no_precompile
            template_fn = eval(template_fn).source

          js_body += """
          #{object_path}.#{info.name} = #{template_fn};


          """
          if argv.compile_style is 'file'
            write()

      if argv.compile_style isnt 'file'
        write()
